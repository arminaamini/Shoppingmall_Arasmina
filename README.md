در این پروژه از ساختار MVC + Sevice + Repository استفاده شده است.لایه Model موجودیت های پروژه مانند اطلاعات کاربران، سبد خرید و محصولات در دسترس را بدون وابستگی بخ سایر لایه های پروژه، نگهداری میکند. کلاس‌های مربوط به کاربران با استفاده از ارث‌بری (Inheritance) طراحی شده‌اند. یک کلاس پایه‌ی User تعریف شده است که ویژگی‌های مشترک میان انواع کاربران مانند شناسه، نام کاربری و رمز عبور هش‌شده را در خود نگه می‌دارد. سپس نقش‌های مختلف سیستم مانند Customer و Admin به‌صورت کلاس‌های فرزند از این کلاس پایه پیاده‌سازی شده‌اند.برای مدل‌سازی محصولات، کلاس Product تعریف شده است که شامل اطلاعات اصلی هر کالا مانند نام، دسته‌بندی، قیمت و موجودی انبار می‌باشد. این کلاس به‌گونه‌ای طراحی شده است که تنها مسئول نگهداری وضعیت یک محصول بوده و هیچ منطق تجاری مانند خرید یا تغییر موجودی را در خود ندارد. اعمال مربوط به مدیریت محصولات در لایه‌ی Service انجام می‌شود.سبد خرید کاربران از طریق کلاس‌های مرتبط با Cart مدل‌سازی شده است. هر سبد خرید شامل مجموعه‌ای از محصولات انتخاب‌شده توسط کاربر می‌باشد و وضعیت آن به‌صورت جداگانه برای هر کاربر نگهداری می‌شود. این طراحی باعث می‌شود که عملیات مربوط به افزودن، حذف و محاسبه‌ی مجموع قیمت به‌صورت شفاف و قابل مدیریت انجام شود، بدون آن‌که وابستگی‌ای به رابط کاربری یا لایه‌ی ذخیره‌سازی داده‌ها ایجاد گردد.

در مجموع، لایه‌ی Model این پروژه صرفاً شامل ساختار داده‌ها و روابط میان موجودیت‌هاست و هیچ منطق وابسته به رابط کاربری یا ذخیره‌سازی در آن قرار نگرفته است.
در لایه view تمامی فرم‌ها، پنل‌ها و اجزای گرافیکی (مانند جدول نمایش محصولات، دکمه‌ها، فیلدهای ورودی و پیام‌های اطلاع‌رسانی) در این  قرار دارند. طراحی View به‌گونه‌ای انجام شده که صرفاً وظیفه‌ی نمایش داده‌ها و دریافت ورودی را بر عهده دارد و منطق در آن وجود ندارد.در این معماری، View برای انجام عملیات‌هایی مانند ورود، مشاهده‌ی کاتالوگ، مدیریت محصولات، مدیریت سبد خرید و مشاهده‌ی نتیجه‌ی عملیات‌ها، تنها رویدادها (Event) را تولید می‌کند و نمایش خروجی را انجام می‌دهد؛ اما تصمیم‌گیری‌ها، اعتبارسنجی‌های اصلی و عملیات‌هایی مثل ثبت خرید، تغییر موجودی، یا ذخیره‌سازی اطلاعات را انجام نمی‌دهد. به این ترتیب، رابط کاربری مستقل از منطق سیستم باقی می‌ماند و در صورت تغییر منطق برنامه یا حتی تغییر نوع رابط کاربری، بدنه‌ی اصلی سیستم کمترین تغییر را خواهد داشت.
لایه‌ی Controller به‌عنوان واسط میان View و سایر لایه‌ها (به‌خصوص Service) عمل می‌کند و نقش اصلی آن مدیریت رویدادهای رابط کاربری و هدایت جریان برنامه است. در این پروژه، کنترلرها مسئول دریافت رویدادهایی هستند که از طریق دکمه‌ها، انتخاب‌ها و ورودی‌های کاربر در محیط Swing ایجاد می‌شوند؛ سپس بر اساس نوع عملیات، سرویس مناسب را فراخوانی می‌کنند و در نهایت نتیجه را به View بازمی‌گردانند تا نمایش داده شود.

کنترلرها به‌گونه‌ای طراحی شده‌اند که View را از منطق اجرایی و تصمیم‌گیری جدا نگه دارند.
لایه‌ی Service در این پروژه به‌عنوان مرکز اصلی منطق سیستم طراحی شده است. تمامی قوانین، تصمیم‌گیری‌ها و پردازش‌های اصلی برنامه در این لایه قرار دارند و هیچ‌کدام از آن‌ها مستقیماً در View یا Controller پیاده‌سازی نشده‌اند. هر Service مسئول انجام یک مجموعه وظایف مشخص است و تنها از طریق Interfaceهای مربوط به Repository با داده‌ها تعامل دارد.هر سرویس تنها مسئول یک حوزه‌ی مشخص از منطق سیستم است. همچنین این لایه به‌جای وابستگی مستقیم به کلاس‌های پیاده‌سازی ذخیره‌سازی داده، به Interfaceها وابسته است.در این پروژه، Repositoryها به‌صورت Interface تعریف شده‌اند و Service Layer تنها از این Interfaceها استفاده می‌کند، بدون آن‌که اطلاعی از نحوه‌ی واقعی ذخیره‌سازی داده‌ها داشته باشد. این طراحی باعث شده است که تغییر تکنولوژی ذخیره‌سازی (مثلاً مهاجرت از JSON به پایگاه داده) بدون ایجاد تغییر در منطق سیستم امکان‌پذیر باشد.

پیاده‌سازی فعلی Repositoryها بر اساس فایل‌های JSON انجام شده است. داده‌هایی مانند کاربران، محصولات و سبدهای خرید پس از هر تغییر در فایل‌های مربوطه ذخیره می‌شوند و هنگام اجرای مجدد برنامه بازیابی می‌گردند. این موضوع باعث شده است که اطلاعات برنامه پس از بسته شدن سیستم از بین نرود و مفهوم Data Persistence به‌صورت کامل در پروژه رعایت شود.سیستم برای افزودن روش‌های ذخیره‌سازی جدید باز است، اما برای تغییر در منطق موجود نیازی به ویرایش کدهای اصلی ندارد.
نقش‌ها و نحوه استفاده کاربران از سیستم

در این سیستم دو نوع کاربر اصلی در نظر گرفته شده است: مشتری و مدیر.
مشتری می‌تواند وارد سیستم شود، محصولات موجود را مشاهده کند، آن‌ها را به سبد خرید خود اضافه یا حذف کند و در نهایت فرآیند خرید را انجام دهد. هر مشتری دارای اطلاعات مشخص و همچنین موجودی حساب است و تنها در صورتی می‌تواند خرید نهایی را انجام دهد که موجودی کافی داشته باشد.

در مقابل، مدیر سیستم وظیفه‌ی مدیریت محصولات را بر عهده دارد. مدیر می‌تواند کالاهای جدید اضافه کند، اطلاعات محصولات موجود را ویرایش کند یا آن‌ها را حذف نماید. این تفکیک نقش‌ها باعث شده است که سیستم رفتار منطقی‌تری داشته باشد و هر کاربر فقط به امکانات مربوط به خود دسترسی داشته باشد.
جریان کلی عملکرد برنامه

عملکرد برنامه به این صورت است که کاربر ابتدا وارد سیستم می‌شود و بر اساس اطلاعات واردشده، نقش او مشخص می‌گردد. پس از ورود، محیط کاربری متناسب با نقش کاربر نمایش داده می‌شود. مشتری پس از مشاهده‌ی فهرست محصولات می‌تواند کالاهای موردنظر خود را انتخاب کرده و به سبد خرید اضافه کند. در هر مرحله، مجموع قیمت و وضعیت سبد خرید به‌صورت پویا به کاربر نمایش داده می‌شود.

در زمان نهایی کردن خرید، سیستم موجودی کالاها و موجودی حساب مشتری را بررسی می‌کند. در صورت کافی بودن شرایط، خرید انجام شده و اطلاعات جدید ذخیره می‌شوند. این فرآیند به‌گونه‌ای طراحی شده است که کاربر بازخورد مناسب دریافت کند و از نتیجه‌ی هر عملیات مطلع شود.
ذخیره‌سازی داده‌ها و ماندگاری اطلاعات

یکی از ویژگی‌های مهم این پروژه، نگهداری اطلاعات پس از بسته شدن برنامه است. اطلاعات مربوط به کاربران، محصولات و سبدهای خرید در فایل‌های متنی با ساختار JSON ذخیره می‌شوند. این کار باعث می‌شود که با اجرای مجدد برنامه، داده‌ها از بین نروند و سیستم بتواند وضعیت قبلی خود را بازیابی کند.

نحوه‌ی ذخیره‌سازی داده‌ها به‌صورت جدا از منطق اصلی برنامه طراحی شده است تا در صورت نیاز، بتوان در آینده روش ذخیره‌سازی را تغییر داد (برای مثال استفاده از پایگاه داده) بدون آن‌که ساختار کلی برنامه دچار مشکل شود.
کلاس‌های بخش مدل

کلاس User پایه‌ی همه‌ی کاربران سیستم است و اطلاعات مشترک مثل نام کاربری، رمز عبورِ ذخیره‌شده و نقش کاربر را نگه می‌دارد. این کلاس همچنین دو کار مهم انجام می‌دهد: یکی اینکه رمز عبوری که کاربر وارد می‌کند را با رمز ذخیره‌شده مقایسه می‌کند تا مشخص شود درست است یا نه، و دوم اینکه امکان تغییر رمز را فراهم می‌کند. این کلاس «انتزاعی» طراحی شده تا به‌تنهایی ساخته نشود و فقط پایه‌ی نقش‌های واقعی مثل مشتری و مدیر باشد.

کلاس Customer نماینده‌ی مشتری است و علاوه بر اطلاعات عمومی کاربر، یک شناسه‌ی مخصوص مشتری و همچنین مقدار موجودی حساب را نگه می‌دارد. این کلاس برای مدیریت موجودی متدهایی مثل افزایش موجودی و برداشت از موجودی دارد و اجازه نمی‌دهد مقدارهای منفی یا برداشت بیش از موجودی انجام شود. این بخش باعث می‌شود مرحله‌ی خرید نهایی منطقی و قابل کنترل باشد.

کلاس Admin نماینده‌ی مدیر سیستم است و عملاً فقط یک کاربر با نقش مدیر محسوب می‌شود. چون مدیر ویژگی اضافه‌ای مثل موجودی ندارد، این کلاس ساده‌تر از مشتری است و نقش آن بیشتر در «دسترسی‌های مدیریتی» مشخص می‌شود.

کلاس Role یک نوع شمارشی است که نقش‌ها را مشخص می‌کند (مشتری یا مدیر). این باعث می‌شود برنامه به‌جای استفاده از متن‌های پراکنده، همیشه نقش‌ها را استاندارد و امن تشخیص بدهد.

کلاس Product نماینده‌ی کالا است و اطلاعات اصلی هر محصول مثل شناسه، نام، دسته‌بندی، قیمت، موجودی، توضیح و حتی یک فیلد برای تصویر را نگه می‌دارد. این کلاس فقط «اطلاعات» را نگه می‌دارد و منطق خرید و تغییر موجودی را مستقیم انجام نمی‌دهد؛ این کارها در بخش سرویس انجام می‌شود تا مسئولیت‌ها قاطی نشوند.

کلاس Cart نماینده‌ی سبد خرید است و یک فهرست از اقلام سبد را نگه می‌دارد. هدف این کلاس فقط نگهداری آیتم‌های انتخاب‌شده‌ی کاربر است و معمولاً محاسبه قیمت و کنترل موجودی در سرویس انجام می‌شود تا مدل بیش از حد سنگین نشود.

کلاس CartItem هر «آیتم سبد خرید» را نمایش می‌دهد؛ یعنی می‌گوید از کدام محصول و به چه تعداد داخل سبد قرار گرفته است. این کلاس به‌جای نگهداری کامل محصول، فقط شناسه محصول و تعداد را نگه می‌دارد تا ذخیره‌سازی ساده‌تر و حجم داده کمتر شود.

کلاس‌های Order و OrderItem برای نمایش مفهوم «سفارش» و «اقلام سفارش» طراحی شده‌اند؛ یعنی اگر در آینده بخواهیم سابقه خریدها را نگه داریم، ساختار آن آماده است. در نسخه فعلی پروژه، خرید نهایی باعث کاهش موجودی و کاهش موجودی حساب و خالی شدن سبد می‌شود، اما نگهداری تاریخچه سفارش می‌تواند توسعه‌ی بعدی باشد.
کلاس‌های بخش سرویس

کلاس AuthService مسئول ورود و ثبت‌نام کاربران است. این کلاس ورودی‌های کاربر را بررسی می‌کند، کاربر را از محل ذخیره‌سازی پیدا می‌کند، رمز را بررسی می‌کند و نتیجه‌ی موفق یا ناموفق را برمی‌گرداند. در ثبت‌نام نیز اگر نام کاربری تکراری نباشد، یک مشتری جدید می‌سازد، رمز را به شکل امن ذخیره می‌کند و کاربر را ثبت می‌کند. خروجی این سرویس به شکلی برگردانده می‌شود که هم پیام داشته باشد و هم داده‌ی لازم را.

کلاس ProductService مسئول مدیریت محصولات است. این سرویس فهرست کالاها را می‌دهد، امکان مرتب‌سازی بر اساس قیمت را فراهم می‌کند و عملیات افزودن، ویرایش و حذف محصول را انجام می‌دهد. هنگام افزودن، بررسی می‌کند نام خالی نباشد و قیمت و موجودی منفی نباشد و بعد یک شناسه مناسب برای محصول می‌سازد تا محصولات مرتب و استاندارد شناسه‌گذاری شوند.

کلاس CartService مسئول کارهای مربوط به سبد خرید است. این سرویس افزودن کالا به سبد، حذف کالا از سبد، خالی کردن سبد و گرفتن خلاصه سبد را انجام می‌دهد. هنگام افزودن یا تغییر تعداد، موجودی محصول بررسی می‌شود تا کاربر نتواند بیشتر از موجودی انبار انتخاب کند. همچنین مجموع قیمت سبد را محاسبه می‌کند تا در رابط کاربری نمایش داده شود.

کلاس CheckOutService مرحله‌ی خرید نهایی را انجام می‌دهد. ابتدا سبد خرید را بررسی می‌کند که خالی نباشد، سپس برای هر کالا موجودی را چک می‌کند و مجموع قیمت را به دست می‌آورد. بعد موجودی حساب مشتری را بررسی می‌کند و اگر کافی باشد، موجودی محصولات را کم می‌کند، از حساب مشتری برداشت می‌کند، اطلاعات جدید را ذخیره می‌کند و در پایان سبد را خالی می‌کند. این کلاس دقیقاً همان جایی است که «منطق خرید واقعی» در پروژه انجام می‌شود.
کلاس‌های بخش ذخیره‌سازی داده

رابط iUserRepository قرارداد ذخیره و بازیابی کاربران را مشخص می‌کند؛ یعنی می‌گوید چه عملیات‌هایی لازم است (گرفتن همه کاربران، پیدا کردن با نام کاربری، ذخیره، حذف و ذخیره گروهی). این کار باعث می‌شود سرویس‌ها به روش ذخیره‌سازی وابسته نباشند.

رابط iProductRepository قرارداد ذخیره و بازیابی محصولات را مشخص می‌کند؛ شامل خواندن همه محصولات، پیدا کردن یک محصول با شناسه و ذخیره لیست محصولات.

رابط iCartRepository قرارداد مدیریت سبد خرید را مشخص می‌کند؛ یعنی بارگذاری سبد یک کاربر، ذخیره سبد و خالی کردن سبد.

کلاس JsonUserRepository پیاده‌سازی ذخیره‌سازی کاربران با فایل JSON است. این کلاس فایل را آماده می‌کند، کاربران را از فایل می‌خواند و بر اساس نقش، آن‌ها را به شکل مشتری یا مدیر می‌سازد. همچنین هنگام ذخیره، اطلاعات هر کاربر را به شکل مناسب در فایل می‌نویسد و اگر کاربر مشتری باشد، شناسه و موجودی او را هم ذخیره می‌کند.

کلاس JsonProductRepository محصولات را از فایل JSON می‌خواند و دوباره در همان فایل ذخیره می‌کند. این کلاس همچنین اگر فایل وجود نداشته باشد آن را ایجاد می‌کند تا برنامه بدون خطا اجرا شود.

کلاس JsonCartRepository برای هر مشتری یک فایل سبد خرید جداگانه می‌سازد (مثلاً بر اساس شناسه مشتری). اگر سبد خرید وجود نداشته باشد، یک سبد خالی ایجاد می‌کند و ذخیره می‌کند. این طراحی باعث می‌شود سبد خرید هر کاربر مستقل باشد و با اجرای مجدد برنامه نیز باقی بماند.
کلاس‌های بخش کنترلر

کلاس LoginController رابط ورود را به سرویس ورود وصل می‌کند. یعنی وقتی کاربر دکمه ورود مشتری یا ورود مدیر یا ثبت‌نام را می‌زند، این کنترل‌گر اطلاعات را از صفحه می‌گیرد، سرویس مربوطه را صدا می‌زند و اگر موفق بود، پنل مناسب را باز می‌کند. به زبان ساده، این کلاس «مدیریت رفتن از صفحه ورود به صفحه مشتری یا مدیر» را انجام می‌دهد.

کلاس CustomerController کنترلر پنل مشتری است. این کلاس وقتی مشتری می‌خواهد محصولی را به سبد اضافه کند، حذف کند، سبد را خالی کند، سبد را به‌روز کند یا خرید نهایی انجام دهد، همه‌ی این درخواست‌ها را به سرویس‌های مربوطه می‌فرستد و نتیجه را روی صفحه نشان می‌دهد. همچنین نمایش موجودی و نمایش اطلاعات پروفایل مشتری هم از همینجا مدیریت می‌شود.

کلاس AdminProductController کنترلر بخش مدیریت محصولات برای مدیر است. این کنترل‌گر بارگذاری لیست محصولات، مرتب‌سازی، افزودن محصول جدید، ویرایش محصول و حذف محصول را مدیریت می‌کند. برای افزودن و ویرایش نیز یک پنجره‌ی ورودی باز می‌کند تا مدیر اطلاعات را وارد کند و بعد آن را به سرویس محصول می‌فرستد.
کلاس‌های بخش رابط کاربری

کلاس LoginFrame صفحه‌ی ورود و ثبت‌نام است. ورودی نام کاربری و رمز را می‌گیرد و دکمه‌های ورود مشتری، ورود مدیر و ثبت‌نام را در اختیار کاربر قرار می‌دهد. همچنین نمایش پیام‌های خطا و پیام‌های موفقیت روی همین صفحه انجام می‌شود.

کلاس CustomerMainFrame صفحه اصلی مشتری است که سبد خرید و عملیات‌های مرتبط با آن را نمایش می‌دهد. این صفحه امکان افزودن کالا به سبد با گرفتن شناسه و تعداد، حذف کالا از جدول سبد، نمایش مجموع قیمت و همچنین انجام خرید نهایی را فراهم می‌کند. نمایش موجودی مشتری و نمایش پروفایل نیز در همین صفحه انجام می‌شود.

کلاس AdminProductFrame پنجره‌ی اصلی مدیر است که برای مدیریت محصولات استفاده می‌شود و معمولاً یک پنل مدیریتی داخل آن قرار می‌گیرد.

کلاس ProductManagementPanel پنل مدیریتی محصولات است که جدول محصولات و دکمه‌های عملیات مدیریتی مثل افزودن، ویرایش، حذف، مرتب‌سازی و تازه‌سازی را نشان می‌دهد. کنترل‌گر مدیر با همین پنل کار می‌کند و این پنل خودش منطق تصمیم‌گیری ندارد.

کلاس ProductFormDialog پنجره‌ی گرفتن اطلاعات محصول است. وقتی مدیر می‌خواهد محصول اضافه یا ویرایش کند، این پنجره باز می‌شود و فیلدهایی مثل نام، دسته‌بندی، قیمت، موجودی و توضیح را می‌گیرد و در نهایت اعلام می‌کند مدیر اطلاعات را تأیید کرده یا منصرف شده است.

کلاس MainFrame نقطه شروع برنامه است؛ یعنی همان جایی که اجزای اصلی ساخته می‌شوند و به هم وصل می‌شوند. در این بخش معمولاً مخزن‌های ذخیره‌سازی ساخته می‌شوند، سرویس‌ها با آن‌ها ساخته می‌شوند، صفحه ورود ساخته می‌شود و کنترل‌گرها به صفحه وصل می‌شوند. این کار باعث می‌شود همه چیز منظم و قابل مدیریت باشد.
کلاس‌های کمکی و انتقال داده

کلاس OperationResult یک قالب استاندارد برای نتیجه عملیات‌هاست. یعنی به‌جای اینکه هرجا روش جداگانه‌ی خطا و موفقیت داشته باشیم، همه سرویس‌ها یک خروجی یکسان می‌دهند: آیا عملیات موفق بوده، پیام چیست و اگر لازم باشد داده‌ی خروجی چیست. این کار کد را مرتب‌تر می‌کند و مدیریت خطا را در رابط کاربری ساده‌تر می‌سازد.

کلاس CartSummary برای انتقال خلاصه سبد خرید بین لایه‌ها استفاده می‌شود. این کلاس معمولاً سبد خرید و مجموع قیمت را با هم نگه می‌دارد تا کنترل‌گر یا رابط کاربری راحت‌تر بتواند اطلاعات لازم را یکجا دریافت کند.

کلاس PasswordHasherUtil برای امن‌تر کردن رمز عبور استفاده می‌شود. به‌جای اینکه رمزها به شکل ساده ذخیره شوند، ابتدا تبدیل به یک مقدار رمزنگاری‌شده می‌شوند و همان مقدار ذخیره می‌شود. در زمان ورود، رمز واردشده هم به همان روش تبدیل می‌شود و با مقدار ذخیره‌شده مقایسه می‌شود.

کلاس DataPaths فقط مسیر فایل‌های ذخیره‌سازی را یکجا نگه می‌دارد تا در کل پروژه پراکنده نشود و اگر مسیرها تغییر کنند، یکجا قابل اصلاح باشند.
